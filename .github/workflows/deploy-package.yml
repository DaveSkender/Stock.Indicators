name: Deploy package

## Version marker and suffix taxonomy
# Version format: major.minor.patch[-preview.N|-ci.X]
# - Versioning managed by GitVersion
# - Suffixes:
#   - Push to main/v* branches (pkg.github.com): `-ci.X` (X = CI build number)
#   - Manual dispatch (preview true, any env): `-preview.N` (N = preview number)
#   - Manual dispatch (preview false, nuget.org, main, dry_run false): (none)
# - Non-preview versions on nuget.org restricted to main branch;
#   runs targeting nuget.org from non-"main" branches will fail early.
# - Default: patch increment unless "+semver:" message found
#   or will use "next-version" if set in config
# - Preview numbers auto-increment (e.g., preview.1 -> preview.2)
# - Branches are only tagged with the version after deployments to nuget.org
# - Only production deployments (non-preview to nuget.org) get "latest" tag
# - Old CI packages (with -ci.X suffix) auto-cleanup after 3 days (keep 5 most recent)

on:
  push:
    branches:
      - "main"
      - "v[0-9]*"

  workflow_dispatch:
    inputs:
      environment:
        description: Deployment environment
        type: choice
        options:
          - pkg.github.com
          - nuget.org
        default: pkg.github.com
        required: true
      preview:
        description: Append preview suffix
        type: boolean
        default: true
        required: true
      dry_run:
        description: "Dry-run only (no deploy)"
        type: boolean
        default: true
        required: true

concurrency:
  group: ${{ github.ref_name }}
  cancel-in-progress: true

permissions:
  contents: write
  packages: write

jobs:
  validate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout source
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Debug GitVersion config presence
        run: cat src/gitversion.yml

      - name: Setup GitVersion Tool
        run: dotnet tool install --global GitVersion.Tool

      - name: Show GitVersion config
        run: dotnet gitversion -config src/gitversion.yml -showconfig

      - name: Show GitVersion output
        run: dotnet gitversion -config src/gitversion.yml -updateassemblyinfo

      - name: Validate deployment settings
        env:
          INPUT_ENVIRONMENT: ${{ github.event.inputs.environment }}
          GITHUB_REF: ${{ github.ref }}
          INPUT_PREVIEW: ${{ github.event.inputs.preview }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          # For push events (CI builds): always publish to GitHub Packages only
          if [[ "$EVENT_NAME" == "push" ]]; then
            echo "‚úÖ CI build detected - will publish to GitHub Packages with -ci suffix"
            exit 0
          fi

          # For manual dispatch: validate deployment settings
          if [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
            # Check if deploying to nuget.org
            if [[ "$INPUT_ENVIRONMENT" == "nuget.org" ]]; then
              # Only main or v* branches can deploy to nuget.org
              if [[ "$GITHUB_REF" != "refs/heads/main" ]] && [[ ! "$GITHUB_REF" =~ ^refs/heads/v[0-9] ]]; then
                echo "::error::Deployments to nuget.org are only allowed from main or v* branches"
                echo "::error::Current branch: $GITHUB_REF"
                echo "::error::To deploy from this branch, use pkg.github.com"
                exit 1
              fi

              # Non-preview (production) versions are only allowed from main branch
              if [[ "$GITHUB_REF" != "refs/heads/main" ]] && [[ "$INPUT_PREVIEW" != "true" ]]; then
                echo "::error::Non-preview (production) versions to nuget.org are only allowed from main branch"
                echo "::error::Current branch: $GITHUB_REF"
                echo "::error::From v* branches, you must set preview=true"
                exit 1
              fi
            fi
          fi

  package:
    needs: validate
    runs-on: ubuntu-latest

    outputs:
      version: ${{ steps.version_info.outputs.version }}
      url: ${{ steps.package_info.outputs.url }}
      name: ${{ steps.package_info.outputs.name }}
      environ: ${{ steps.settings.outputs.environ }}
      preview: ${{ steps.settings.outputs.preview }}
      dry_run: ${{ steps.settings.outputs.dry_run }}
      is_ci_push: ${{ steps.settings.outputs.is_ci_push }}

    steps:
      - name: Set default inputs for dispatch
        id: settings
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environ=${{ inputs.environment }}" >> $GITHUB_OUTPUT
            echo "preview=${{ inputs.preview }}" >> $GITHUB_OUTPUT
            echo "dry_run=${{ inputs.dry_run }}" >> $GITHUB_OUTPUT
            echo "is_ci_push=false" >> $GITHUB_OUTPUT
          else
            # Push to main/v* branches: publish to GitHub Packages with CI suffix
            echo "environ=pkg.github.com" >> $GITHUB_OUTPUT
            echo "preview=true" >> $GITHUB_OUTPUT
            echo "dry_run=false" >> $GITHUB_OUTPUT
            echo "is_ci_push=true" >> $GITHUB_OUTPUT
          fi

      - name: Checkout source
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: "9.x"
          dotnet-quality: "ga"
          cache: true
          cache-dependency-path: "**/packages.lock.json"

      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y libxml2-utils
          dotnet tool install --global GitVersion.Tool

      - name: Show GitVersion config
        run: dotnet gitversion -config src/gitversion.yml -showconfig

      - name: Generate version info
        id: gitversion
        run: |
          dotnet gitversion -config src/gitversion.yml -updateassemblyinfo
          # Export GitVersion variables to environment
          dotnet gitversion -config src/gitversion.yml | jq -r 'to_entries[] | "\(.key)=\(.value)"' >> $GITHUB_ENV

      - name: Compose version
        id: version_info
        run: |
          # base version
          base="${{ env.MajorMinorPatch }}"

          # conditional suffix
          if [[ "${{ steps.settings.outputs.preview }}" == "true" ]]; then
            # CI pushes use only -ci.X suffix
            if [[ "${{ steps.settings.outputs.is_ci_push }}" == "true" ]]; then
              suffix="-ci.${{ env.CommitsSinceVersionSource }}"
            elif [[ -n "${{ env.PreReleaseTag }}" ]]; then
              suffix="-${{ env.PreReleaseTag }}.${{ env.PreReleaseNumber }}"
            else
              suffix="-preview.${{ env.CommitsSinceVersionSource }}"
            fi
          else
            suffix=""
          fi

          ver="${base}${suffix}"
          echo "version=$ver" >> $GITHUB_OUTPUT
          echo "Generated version: $ver"

      - name: Replace "dumb" version markers
        uses: jacobtomlinson/gha-find-replace@f1069b438f125e5395d84d1c6fd3b559a7880cb5
        with:
          find: "#{PACKAGE_VERSION}#"
          replace: "${{ steps.version_info.outputs.version }}"
          regex: false

      - name: Compose package info
        id: package_info
        run: |
          PACKAGE_NAME=$(xmllint --xpath "//PropertyGroup/PackageId/text()" src/Indicators.csproj)
          echo "name=${PACKAGE_NAME}" >> $GITHUB_OUTPUT
          if [[ "${{ steps.settings.outputs.environ }}" == "nuget.org" ]]; then
            echo "url=https://www.nuget.org/packages/${PACKAGE_NAME}/${{ steps.version_info.outputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "url=https://github.com/${{ github.repository }}/pkgs/nuget/${PACKAGE_NAME}" >> $GITHUB_OUTPUT
          fi

      - name: Build library
        run: >
          dotnet build src/Indicators.csproj
          --configuration Release
          --property:Version=${{ steps.version_info.outputs.version }}
          --property:DefineConstants=VERSIONED_BUILD
          --property:ContinuousIntegrationBuild=true
          -warnAsError

      - name: Pack for NuGet
        run: >
          dotnet pack src/Indicators.csproj
          --configuration Release
          --no-build
          --include-symbols
          --output NuGet
          -p:PackageVersion=${{ steps.version_info.outputs.version }}

      - name: Save package
        uses: actions/upload-artifact@v4
        with:
          name: packages
          path: NuGet
          include-hidden-files: true

      - name: Summary output
        if: always()
        run: |
          {
            echo "| Version No.       | Component                                        |"
            echo "| :---------------- | :----------------------------------------------- |"
            echo "| Mode              | ${{ steps.settings.outputs.dry_run && 'üîç DRY RUN' || 'üöÄ DEPLOY' }} |"
            echo "| Status            | ${{ job.status == 'success' && '‚úÖ Success' || '‚ùå Failed' }} |"
            echo "| Package URL       | ${{ steps.package_info.outputs.url }}            |"
          } >> $GITHUB_STEP_SUMMARY

  deploy:
    needs: package
    runs-on: ubuntu-latest
    if: success()

    permissions:
      contents: write
      packages: write

    environment:
      name: ${{ needs.package.outputs.environ != '' && needs.package.outputs.environ || null }}
      url: ${{ needs.package.outputs.url }}

    env:
      version: ${{ needs.package.outputs.version }}
      preview: ${{ needs.package.outputs.preview }}
      dry_run: ${{ needs.package.outputs.dry_run }}
      environ: ${{ needs.package.outputs.environ }}
      url: ${{ needs.package.outputs.url }}
      name: ${{ needs.package.outputs.name }}
      NUGET_PUBLISH_URL: ${{ needs.package.outputs.environ == 'nuget.org' && 'https://api.nuget.org/v3/index.json' || format('https://nuget.pkg.github.com/{0}/index.json', github.repository_owner) }}
      NUGET_API_KEY: ${{ needs.package.outputs.environ == 'nuget.org' && secrets.NUGET_TOKEN || secrets.GITHUB_TOKEN }}

    steps:
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: "9.x"
          dotnet-quality: "ga"

      - name: Download package
        uses: actions/download-artifact@v5
        with:
          name: packages
          path: NuGet

      - name: Publish package
        if: ${{ env.dry_run != 'true' }}
        run: >
          dotnet nuget push NuGet/*.nupkg
          --source "${{ env.NUGET_PUBLISH_URL }}"
          --api-key "${{ env.NUGET_API_KEY }}"
          --skip-duplicate

      - name: Manage GitHub Packages latest tag
        if: ${{ !env.dry_run && env.environ == 'pkg.github.com' }}
        env:
          GH_TOKEN: ${{ env.NUGET_API_KEY }}
        run: |
          # Only production (non-preview) deployments from main branch should become 'latest'
          # GitHub Packages automatically marks the highest semantic version without pre-release identifiers as 'latest'
          if [[ "${{ env.preview }}" == "false" ]] && [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "üè∑Ô∏è This is a production deployment from main - will be marked as latest by GitHub Packages"
            echo "   (no pre-release suffix, so it will automatically become latest if it's the highest version)"
          else
            echo "üè∑Ô∏è This is a preview/CI deployment or not from main - will NOT be marked as latest"
            echo "   (has pre-release suffix: ${{ env.version }})"
          fi

          echo "üì¶ Published ${{ env.name }} version ${{ env.version }} to GitHub Packages"

      - name: Tag and draft release note
        uses: ncipollo/release-action@v1
        if: ${{ !env.dry_run && env.environ == 'nuget.org' }}
        with:
          body: |
            - **Preview**: ${{ env.preview && 'Yes' || 'No' }}
          generateReleaseNotes: true
          draft: true
          makeLatest: ${{ !env.preview && env.environ == 'nuget.org' && github.ref == 'refs/heads/main' }}
          prerelease: ${{ env.preview }}
          tag: v${{ env.version }}
          commit: ${{ github.sha }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Deployment summary
        if: always()
        run: |
          {
            echo "| Preview     | ${{ env.preview && '‚úì' || '‚úó' }} |"
          } >> $GITHUB_STEP_SUMMARY

  cleanup:
    needs: [package, deploy]
    runs-on: ubuntu-latest
    if: success() && needs.package.outputs.is_ci_push == 'true' && needs.package.outputs.dry_run != 'true'

    permissions:
      packages: write

    env:
      PACKAGE_NAME: ${{ needs.package.outputs.name }}
      REPO_OWNER: ${{ github.repository_owner }}

    steps:
      - name: Cleanup old CI packages
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîç Cleaning up old CI packages for ${PACKAGE_NAME}"

          # Get all package versions with pagination support
          page=1
          all_versions="[]"
          while true; do
            # Capture both stdout and stderr, check exit code
            set +e
            response=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/orgs/${REPO_OWNER}/packages/nuget/${PACKAGE_NAME}/versions?per_page=100&page=${page}" 2>&1)
            exit_code=$?
            set -e

            # If API call failed, check if it's a real error
            if [[ $exit_code -ne 0 ]]; then
              echo "‚ö†Ô∏è  GitHub API call failed (exit code: ${exit_code})"
              echo "‚ö†Ô∏è  Response: $response"
              # If this is the first page and we got an error, the package might not exist yet
              if [[ $page -eq 1 ]]; then
                echo "‚úÖ No packages found (possibly none exist yet)"
                exit 0
              fi
              break
            fi

            # Validate response is valid JSON array
            if ! echo "$response" | jq -e 'type == "array"' >/dev/null 2>&1; then
              echo "‚ö†Ô∏è  GitHub API returned non-array response: $response"
              # If this is the first page, likely an error (e.g., package doesn't exist)
              if [[ $page -eq 1 ]]; then
                echo "‚úÖ No packages found to clean up"
                exit 0
              fi
              break
            fi

            # If response is an empty array, we've reached the end
            response_length=$(echo "$response" | jq 'length')
            if [[ $response_length -eq 0 ]]; then
              break
            fi

            # Safely merge arrays
            all_versions=$(jq -n --argjson prev "$all_versions" --argjson curr "$response" '$prev + $curr')
            ((page++))
          done

          echo "üì¶ Found $(echo "$all_versions" | jq 'length') total package versions"

          # Filter to CI packages only (containing -ci. suffix)
          ci_versions=$(echo "$all_versions" | jq '[.[] | select(.name | contains("-ci."))]')
          ci_count=$(echo "$ci_versions" | jq 'length')
          echo "üîß Found ${ci_count} CI package versions"

          if [[ $ci_count -eq 0 ]]; then
            echo "‚úÖ No CI packages to clean up"
            exit 0
          fi

          # Sort by created_at descending (newest first)
          sorted_versions=$(echo "$ci_versions" | jq 'sort_by(.created_at) | reverse')

          # Calculate cutoff date (3 days ago)
          cutoff_date=$(date -u -d '3 days ago' +%Y-%m-%dT%H:%M:%SZ)
          echo "üìÖ Cutoff date: ${cutoff_date}"

          # Keep the 5 most recent, delete older ones that are past cutoff
          deleted_count=0
          index=0

          # Use process substitution to avoid subshell issues
          while IFS= read -r version; do
            version_id=$(echo "$version" | jq -r '.id')
            version_name=$(echo "$version" | jq -r '.name')
            created_at=$(echo "$version" | jq -r '.created_at')

            # Keep the first 5 (most recent)
            if [[ $index -lt 5 ]]; then
              echo "‚è≠Ô∏è  Keeping recent version: ${version_name} (created: ${created_at})"
            # Delete if older than 3 days
            elif [[ "$created_at" < "$cutoff_date" ]]; then
              echo "üóëÔ∏è  Deleting old version: ${version_name} (created: ${created_at})"
              if gh api \
                --method DELETE \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "/orgs/${REPO_OWNER}/packages/nuget/${PACKAGE_NAME}/versions/${version_id}" 2>/dev/null; then
                ((deleted_count++))
              else
                echo "‚ö†Ô∏è  Failed to delete version: ${version_name}"
              fi
            else
              echo "‚è≠Ô∏è  Keeping recent version: ${version_name} (created: ${created_at}, within 3 days)"
            fi

            ((index++))
          done < <(echo "$sorted_versions" | jq -c '.[]')

          echo "‚úÖ Cleanup complete. Deleted ${deleted_count} old CI package versions"

          {
            echo "### üßπ Package Cleanup Summary"
            echo "| Metric | Value |"
            echo "| :----- | :---- |"
            echo "| Total CI Packages | ${ci_count} |"
            echo "| Packages Deleted | ${deleted_count} |"
            echo "| Packages Retained | $((ci_count - deleted_count)) |"
          } >> $GITHUB_STEP_SUMMARY
