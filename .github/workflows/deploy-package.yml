name: Deploy package

## Version marker and suffix taxonomy
# Version format: major.minor.patch[-label.N]
# Versioning managed by GitVersion (see src/gitversion.yml)
#
# Automatic versioning by branch:
#   main branch: 2.x.x-ci.N (CI) or 2.x.x (production)
#   v3 branch: 3.0.0-preview.N (always preview)
#   feature branches: x.x.x-{branch-name}.N
#
# Manual dispatch controls:
#   - environment: pkg.github.com or nuget.org
#   - preview: true (keep pre-release suffix) or false (production version)
#   - dry_run: true (test only) or false (actually publish)
#
# Version suffix behavior:
#   - CI push events: Use GitVersion FullSemVer (includes +metadata)
#   - Manual with preview=true: Use GitVersion NuGetVersionV2 (pre-release)
#   - Manual with preview=false: Use GitVersion MajorMinorPatch (stable)
#
# Deployment restrictions:
#   - Production versions (no suffix) to nuget.org: main branch only
#   - Preview versions: any branch
#   - Tags created: only for production deployments to nuget.org
#   - 'latest' tag: only for production deployments from main to nuget.org
#
# Package cleanup:
#   - All packages in GitHub Packages are CI/preview builds (stable â†’ NuGet.org)
#   - Auto-cleanup after {retentionDays} days (always keep {keepCount} most recent)

on:
  push:
    branches:
      - "main"
      - "v[0-9]*"

  workflow_dispatch:
    inputs:
      environment:
        description: Deployment environment
        type: choice
        options:
          - pkg.github.com
          - nuget.org
        default: pkg.github.com
        required: true
      preview:
        description: Append preview suffix
        type: boolean
        default: true
        required: true
      dry_run:
        description: "Dry-run only (no deploy)"
        type: boolean
        default: true
        required: true

concurrency:
  group: ${{ github.ref_name }}
  cancel-in-progress: true

permissions:
  contents: write
  packages: write

jobs:
  validate:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout source
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup GitVersion Tool
        run: dotnet tool install --global GitVersion.Tool

      - name: Validate deployment settings
        env:
          INPUT_ENVIRONMENT: ${{ github.event.inputs.environment }}
          GITHUB_REF: ${{ github.ref }}
          INPUT_PREVIEW: ${{ github.event.inputs.preview }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          # For push events (CI builds): always publish to GitHub Packages only
          if [[ "$EVENT_NAME" == "push" ]]; then
            echo "âœ… CI build detected - will publish to GitHub Packages"
            exit 0
          fi

          # For manual dispatch: validate deployment settings
          if [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
            # Check if deploying to nuget.org
            if [[ "$INPUT_ENVIRONMENT" == "nuget.org" ]]; then
              # Only main or v* branches can deploy production versions to nuget.org
              if [[ "$GITHUB_REF" != "refs/heads/main" ]] && [[ ! "$GITHUB_REF" =~ ^refs/heads/v[0-9] ]]; then
                echo "::error::Production deployments to nuget.org require main or v* branch"
                echo "::error::Current branch: $GITHUB_REF"
                echo "::error::Options: 1) Use pkg.github.com, or 2) Set preview=true"
                exit 1
              fi

              # Non-preview versions to nuget.org must be from main or release branches
              if [[ "$INPUT_PREVIEW" == "false" ]] && [[ "$GITHUB_REF" != "refs/heads/main" ]]; then
                echo "::error::Stable versions (preview=false) can only be deployed from main branch"
                echo "::error::Current branch: $GITHUB_REF"
                echo "::error::Options: 1) Switch to main, or 2) Set preview=true for pre-release"
                exit 1
              fi

              # Non-preview (production) versions are only allowed from main branch
              if [[ "$GITHUB_REF" != "refs/heads/main" ]] && [[ "$INPUT_PREVIEW" != "true" ]]; then
                echo "::error::Non-preview (production) versions to nuget.org are only allowed from main branch"
                echo "::error::Current branch: $GITHUB_REF"
                echo "::error::From v* branches, you must set preview=true"
                exit 1
              fi
            fi
          fi

  package:
    needs: validate
    runs-on: ubuntu-latest
    timeout-minutes: 30

    outputs:
      version: ${{ steps.version_info.outputs.version }}
      url: ${{ steps.package_info.outputs.url }}
      name: ${{ steps.package_info.outputs.name }}
      environ: ${{ steps.settings.outputs.environ }}
      preview: ${{ steps.settings.outputs.preview }}
      dry_run: ${{ steps.settings.outputs.dry_run }}
      is_ci_push: ${{ steps.settings.outputs.is_ci_push }}

    steps:
      - name: Set default inputs for dispatch
        id: settings
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environ=${{ inputs.environment }}" >> $GITHUB_OUTPUT
            echo "preview=${{ inputs.preview }}" >> $GITHUB_OUTPUT
            echo "dry_run=${{ inputs.dry_run }}" >> $GITHUB_OUTPUT
            echo "is_ci_push=false" >> $GITHUB_OUTPUT
          else
            # Push to main/v* branches: publish to GitHub Packages with CI suffix
            echo "environ=pkg.github.com" >> $GITHUB_OUTPUT
            echo "preview=true" >> $GITHUB_OUTPUT
            echo "dry_run=false" >> $GITHUB_OUTPUT
            echo "is_ci_push=true" >> $GITHUB_OUTPUT
          fi

      - name: Checkout source
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: "10.x"
          dotnet-quality: "ga"
          cache: true
          cache-dependency-path: "**/packages.lock.json"

      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y libxml2-utils
          dotnet tool install --global GitVersion.Tool

      - name: Show GitVersion config
        run: dotnet gitversion -config src/gitversion.yml -showconfig

      - name: Generate version info
        id: gitversion
        run: |
          dotnet gitversion -config src/gitversion.yml -updateassemblyinfo
          # Export GitVersion variables to environment
          dotnet gitversion -config src/gitversion.yml | jq -r 'to_entries[] | "\(.key)=\(.value)"' >> $GITHUB_ENV

      - name: Compose version
        id: version_info
        run: |
          # Select appropriate GitVersion variable based on deployment scenario
          # See: https://gitversion.net/docs/reference/variables

          if [[ "${{ steps.settings.outputs.is_ci_push }}" == "true" ]]; then
            # CI push events: use FullSemVer (includes build metadata)
            # Examples: 3.0.0-preview.2+5, 2.7.1-ci.3+2
            ver="${{ env.FullSemVer }}"
            echo "Using FullSemVer for CI push: $ver"

          elif [[ "${{ steps.settings.outputs.preview }}" == "true" ]]; then
            # Manual preview: use NuGetVersionV2 (pre-release without metadata)
            # Examples: 3.0.0-preview.2, 2.7.1-ci.3
            ver="${{ env.NuGetVersionV2 }}"
            echo "Using NuGetVersionV2 for preview release: $ver"

          else
            # Production release: use MajorMinorPatch (no suffix)
            # Examples: 3.0.0, 2.7.1
            ver="${{ env.MajorMinorPatch }}"
            echo "Using MajorMinorPatch for production release: $ver"
          fi

          echo "version=$ver" >> $GITHUB_OUTPUT
          echo "Generated version: $ver"

      - name: Replace "dumb" version markers
        uses: jacobtomlinson/gha-find-replace@v3
        with:
          find: "#{PACKAGE_VERSION}#"
          replace: "${{ steps.version_info.outputs.version }}"
          regex: false

      - name: Compose package info
        id: package_info
        run: |
          PACKAGE_NAME=$(xmllint --xpath "//PropertyGroup/PackageId/text()" src/Indicators.csproj)
          echo "name=${PACKAGE_NAME}" >> $GITHUB_OUTPUT
          if [[ "${{ steps.settings.outputs.environ }}" == "nuget.org" ]]; then
            echo "url=https://www.nuget.org/packages/${PACKAGE_NAME}/${{ steps.version_info.outputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "url=https://github.com/${{ github.repository }}/pkgs/nuget/${PACKAGE_NAME}" >> $GITHUB_OUTPUT
          fi

      - name: Build library
        run: >
          dotnet build src/Indicators.csproj
          --configuration Release
          --property:Version=${{ steps.version_info.outputs.version }}
          --property:DefineConstants=VERSIONED_BUILD
          --property:ContinuousIntegrationBuild=true
          -warnAsError

      - name: Pack for NuGet
        run: >
          dotnet pack src/Indicators.csproj
          --configuration Release
          --no-build
          --include-symbols
          --output NuGet
          -p:PackageVersion=${{ steps.version_info.outputs.version }}

      - name: Save package
        uses: actions/upload-artifact@v6
        with:
          name: packages
          path: NuGet
          include-hidden-files: true

      - name: Summary output
        if: always()
        run: |
          # Determine mode label
          if [[ "${{ steps.settings.outputs.dry_run }}" == "true" ]]; then
            MODE="ðŸ” DRY RUN"
          elif [[ "${{ steps.settings.outputs.is_ci_push }}" == "true" ]]; then
            MODE="ðŸ”§ CI BUILD"
          else
            MODE="ðŸš€ DEPLOY"
          fi

          {
            echo "| Version No.       | Component                                        |"
            echo "| :---------------- | :----------------------------------------------- |"
            echo "| Version           | ${{ steps.version_info.outputs.version }}        |"
            echo "| Environment       | ${{ steps.settings.outputs.environ }}            |"
            echo "| Mode              | ${MODE}                                          |"
            echo "| Status            | ${{ job.status == 'success' && 'âœ… Success' || 'âŒ Failed' }} |"
            echo "| Package URL       | ${{ steps.package_info.outputs.url }}            |"
          } >> $GITHUB_STEP_SUMMARY

  deploy:
    needs: package
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: success()

    permissions:
      contents: write
      packages: write
      id-token: write # Required for OIDC authentication to nuget.org

    environment:
      name: ${{ needs.package.outputs.environ != '' && needs.package.outputs.environ || null }}
      url: ${{ needs.package.outputs.url }}

    env:
      version: ${{ needs.package.outputs.version }}
      preview: ${{ needs.package.outputs.preview }}
      dry_run: ${{ needs.package.outputs.dry_run }}
      environ: ${{ needs.package.outputs.environ }}
      url: ${{ needs.package.outputs.url }}
      name: ${{ needs.package.outputs.name }}
      NUGET_PUBLISH_URL: ${{ needs.package.outputs.environ == 'nuget.org' && 'https://api.nuget.org/v3/index.json' || format('https://nuget.pkg.github.com/{0}/index.json', github.repository_owner) }}
      NUGET_API_KEY: ${{ needs.package.outputs.environ == 'nuget.org' && secrets.NUGET_TOKEN || secrets.GITHUB_TOKEN }}

    steps:
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: "10.x"
          dotnet-quality: "ga"

      - name: Download package
        uses: actions/download-artifact@v5
        with:
          name: packages
          path: NuGet

      - name: NuGet login (OIDC â†’ temp API key)
        if: ${{ env.dry_run != 'true' && env.environ == 'nuget.org' }}
        uses: NuGet/login@v1
        id: nuget_login
        with:
          user: ${{ secrets.NUGET_USER }}

      - name: Publish package
        if: ${{ env.dry_run != 'true' }}
        run: >
          dotnet nuget push NuGet/*.nupkg
          --source "${{ env.NUGET_PUBLISH_URL }}"
          --api-key "${{ env.environ == 'nuget.org' && steps.nuget_login.outputs.NUGET_API_KEY || env.NUGET_API_KEY }}"
          --skip-duplicate

      - name: Manage GitHub Packages latest tag
        if: ${{ !env.dry_run && env.environ == 'pkg.github.com' }}
        env:
          GH_TOKEN: ${{ env.NUGET_API_KEY }}
        run: |
          # Only production (non-preview) deployments from main branch should become 'latest'
          # GitHub Packages automatically marks the highest semantic version without pre-release identifiers as 'latest'
          if [[ "${{ env.preview }}" == "false" ]] && [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ðŸ·ï¸ This is a production deployment from main - will be marked as latest by GitHub Packages"
            echo "   (no pre-release suffix, so it will automatically become latest if it's the highest version)"
          else
            echo "ðŸ·ï¸ This is a preview/CI deployment or not from main - will NOT be marked as latest"
            echo "   (has pre-release suffix: ${{ env.version }})"
          fi

          echo "ðŸ“¦ Published ${{ env.name }} version ${{ env.version }} to GitHub Packages"

      - name: Tag and draft release note
        uses: ncipollo/release-action@v1
        if: ${{ !env.dry_run && env.environ == 'nuget.org' }}
        with:
          body: |
            - **Preview**: ${{ env.preview && 'Yes' || 'No' }}
          generateReleaseNotes: true
          draft: true
          makeLatest: ${{ !env.preview && env.environ == 'nuget.org' && github.ref == 'refs/heads/main' }}
          prerelease: ${{ env.preview }}
          tag: v${{ env.version }}
          commit: ${{ github.sha }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Deployment summary
        if: always()
        run: |
          {
            echo "| Preview     | ${{ env.preview && 'âœ“' || 'âœ—' }} |"
          } >> $GITHUB_STEP_SUMMARY

  cleanup:
    needs: [package, deploy]
    runs-on: ubuntu-latest
    if: success() && needs.package.outputs.is_ci_push == 'true' && needs.package.outputs.dry_run != 'true'

    permissions:
      packages: write

    env:
      PACKAGE_NAME: ${{ needs.package.outputs.name }}
      REPO_OWNER: ${{ github.repository_owner }}

    steps:
      - name: Cleanup old packages
        uses: actions/github-script@v8
        continue-on-error: true
        with:
          script: |
            const packageName = '${{ needs.package.outputs.name }}';
            const owner = context.repo.owner;
            const retentionDays = 90;
            const keepCount = 10;

            console.log(`ðŸ” Cleaning up old packages for ${packageName}`);
            console.log(`ðŸ“¦ Owner: ${owner}`);
            console.log(`â° Retention: ${retentionDays} days, keeping ${keepCount} most recent`);

            try {
              // Get all package versions
              const { data: versions } = await github.rest.packages.getAllPackageVersionsForPackageOwnedByUser({
                package_type: 'nuget',
                package_name: packageName,
                username: owner,
              });

              console.log(`ðŸ“¦ Found ${versions.length} total package versions`);

              if (versions.length === 0) {
                console.log('âœ… No packages to clean up');
                return;
              }

              // Sort by creation date (newest first)
              const sortedVersions = versions.sort((a, b) =>
                new Date(b.created_at) - new Date(a.created_at)
              );

              // Calculate cutoff date
              const cutoffDate = new Date();
              cutoffDate.setDate(cutoffDate.getDate() - retentionDays);
              console.log(`ðŸ“… Cutoff date: ${cutoffDate.toISOString()}`);

              let deletedCount = 0;
              let keptCount = 0;

              for (let i = 0; i < sortedVersions.length; i++) {
                const version = sortedVersions[i];
                const createdAt = new Date(version.created_at);

                // Keep the N most recent versions
                if (i < keepCount) {
                  console.log(`â­ï¸  Keeping recent version: ${version.name} (created: ${version.created_at})`);
                  keptCount++;
                  continue;
                }

                // Delete if older than retention period
                if (createdAt < cutoffDate) {
                  console.log(`ðŸ—‘ï¸  Deleting old version: ${version.name} (created: ${version.created_at})`);
                  try {
                    await github.rest.packages.deletePackageVersionForUser({
                      package_type: 'nuget',
                      package_name: packageName,
                      username: owner,
                      package_version_id: version.id,
                    });
                    deletedCount++;
                  } catch (error) {
                    console.log(`âš ï¸  Failed to delete version ${version.name}: ${error.message}`);
                    keptCount++;
                  }
                } else {
                  console.log(`â­ï¸  Keeping recent version: ${version.name} (created: ${version.created_at}, within ${retentionDays} days)`);
                  keptCount++;
                }
              }

              console.log(`âœ… Cleanup complete. Deleted ${deletedCount}, kept ${keptCount}`);

              // Add summary
              await core.summary
                .addHeading('ðŸ§¹ Package Cleanup Summary', 3)
                .addTable([
                  [{data: 'Metric', header: true}, {data: 'Value', header: true}],
                  ['Total Packages', versions.length.toString()],
                  ['Packages Deleted', deletedCount.toString()],
                  ['Packages Retained', keptCount.toString()],
                  ['Retention Period', `${retentionDays} days`],
                  ['Keep Most Recent', keepCount.toString()]
                ])
                .write();

            } catch (error) {
              console.log(`âš ï¸  Cleanup failed: ${error.message}`);
              console.log('This may be because the package does not exist yet or permission issues.');
            }
