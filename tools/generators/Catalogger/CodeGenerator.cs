namespace Generators.Catalogger;

/// <summary>
/// Generates catalog code from indicator information.
/// </summary>
internal static class CodeGenerator
{
    internal static void GenerateOutput(
        SourceProductionContext context,
        List<IndicatorInfo> indicators)
    {
        // Generate catalog class
        string sourceCode = GenerateCatalogClass(indicators);
        context.AddSource("Catalog.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
    }

    /// <summary>
    /// Get version dynamically - uses compile-time constant in CI or timestamp locally
    /// </summary>
    internal static string GetGeneratorVersion() =>
#if VERSIONED_BUILD
        // This value will be replaced during CI build
        "#{PACKAGE_VERSION}#";
#else
        // For local builds, use a timestamp-based version
        DateTime.Now.ToString("yyyy.MM.dd-HH:mm:ss.fff");
#endif

    private static string GenerateCatalogClass(List<IndicatorInfo> indicators)
    {
        StringBuilder sourceBuilder = new();

        // Get the version string
        string version = GetGeneratorVersion();

        // File header and namespaces
        sourceBuilder.AppendLine("// <auto-generated/>");
        sourceBuilder.AppendLine("using System.Collections.Generic;");
        sourceBuilder.AppendLine("using System.Linq;");
        sourceBuilder.AppendLine("using System.CodeDom.Compiler;");
        sourceBuilder.AppendLine("");
        sourceBuilder.AppendLine("namespace Skender.Stock.Indicators;");
        sourceBuilder.AppendLine("");
        sourceBuilder.AppendLine("/// <summary>");
        sourceBuilder.AppendLine("/// Auto-generated catalog of all indicators in the library");
        sourceBuilder.AppendLine("/// </summary>");
        sourceBuilder.AppendLine($"[GeneratedCode(\"Indicators.Catalog.Generator\", \"{version}\")]");
        sourceBuilder.AppendLine("public static partial class Catalog");
        sourceBuilder.AppendLine("{");

        // Generate the GeneratedListings property implementation
        sourceBuilder.AppendLine("""
            /// <summary>
            /// Gets all indicator listings in the catalog (auto-generated)
            /// </summary>
            private static partial IReadOnlyList<IndicatorListing> GeneratedListings
            {
                get {
                    List<IndicatorListing> indicators = new()
                    {
        """);

        // Add all found indicators to the collection
        foreach (IndicatorInfo? indicator in indicators.OrderBy(i => i.Name))
        {
            AppendIndicatorListing(sourceBuilder, indicator);
        }

        // Finalize class content
        sourceBuilder.AppendLine("""
                    };

                    return indicators;
                }
            }
        }
        """);

        return sourceBuilder.ToString();
    }

    private static void AppendIndicatorListing(
        StringBuilder sourceBuilder,
        IndicatorInfo indicator)
    {
        // Use the indicator name directly without appending the type
        string displayName = indicator.Name;

        // Build tooltip template based on parameters or use the legend override
        string legendTemplate = indicator.Parameters.Count > 0
                ? $"{indicator.Uiid}("
                            + string.Join(",",
                                Enumerable
                                    .Range(1, indicator.Parameters.Count)
                                    .Select(i => $"[P{i}]")
                                ) + ")"
                : indicator.Uiid;

        // Use the legend override if provided
        if (indicator.LegendOverride != null
         && indicator.LegendOverride != string.Empty)
        {
            legendTemplate = indicator.LegendOverride;
        }

        sourceBuilder.AppendLine($$"""
                    new IndicatorListing
                    {
                        Name = "{{displayName}}",
                        Uiid = "{{indicator.Uiid}}",
                        Category = Category.{{indicator.Category}},
                        ChartType = ChartType.{{indicator.ChartType}},
                        Order = Order.Front,
                        ChartConfig = null,
                        LegendTemplate = "{{legendTemplate}}",
        """);

        // Add parameters
        if (indicator.Parameters.Count > 0)
        {
            sourceBuilder.AppendLine("""
                            Parameters = new List<IndicatorParamConfig>
                            {
            """);

            foreach (ParameterInfo param in indicator.Parameters)
            {
                AppendParameterConfig(sourceBuilder, param);
            }

            sourceBuilder.AppendLine("                },");
        }
        else
        {
            sourceBuilder.AppendLine("                Parameters = new List<IndicatorParamConfig>(),");
        }

        // Add result configs
        AppendResultConfig(sourceBuilder, indicator.Name, indicator.Uiid, legendTemplate);

        sourceBuilder.AppendLine("            },");
    }

    private static void AppendParameterConfig(StringBuilder sourceBuilder, ParameterInfo param)
    {
        // Format numeric values as strings with null support
        string minValueStr = param.MinValue.HasValue ? FormatNumericValue(param.MinValue.Value) : "null";
        string maxValueStr = param.MaxValue.HasValue ? FormatNumericValue(param.MaxValue.Value) : "null";
        string defaultValueStr = param.DefaultValue.HasValue ? FormatNumericValue(param.DefaultValue.Value) : "null";

        sourceBuilder.AppendLine($$"""
                            new IndicatorParamConfig
                            {
                                ParamName = "{{param.Name}}"
                               ,DisplayName = "{{param.DisplayName}}"
                               ,DataType = "{{param.DataType}}"
                               ,DefaultValue = {{defaultValueStr}}
                               ,Minimum = {{minValueStr}}
                               ,Maximum = {{maxValueStr}}
        """);

        // Add enum values if present
        if (param.EnumOptions != null && param.EnumOptions.Count > 0)
        {
            sourceBuilder.AppendLine("""
                               ,EnumOptions = new Dictionary<int, string>
                                {
            """);

            foreach (KeyValuePair<int, string> kvp in param.EnumOptions)
            {
                sourceBuilder.AppendLine($"                            [{kvp.Key}] = \"{kvp.Value}\",");
            }

            sourceBuilder.AppendLine("                        }");
        }

        sourceBuilder.AppendLine("                    },");
    }

    private static void AppendResultConfig(
        StringBuilder sourceBuilder, string name, string id, string tooltipTemplate)
        => sourceBuilder.AppendLine($$"""
                    Results = new List<IndicatorResultConfig>
                    {
                        new IndicatorResultConfig
                        {
                            DataName = "{{id.ToLowerInvariant()}}",
                            DisplayName = "{{name}}",
                            TooltipTemplate = "{{tooltipTemplate}}",
                            DataType = "number",
                            DefaultColor = ChartColors.StandardBlue,
                            LineType = "solid",
                            LineWidth = 2,
                            Stack = null,
                            Fill = null
                        }
                    }
    """);

    /// <summary>
    /// Formats a numeric value as a string without the 'd' suffix.
    /// </summary>
    private static string FormatNumericValue(double value)
    {
        // Handle special values like infinity
        if (double.IsPositiveInfinity(value))
        {
            return "double.PositiveInfinity";
        }
        else if (double.IsNegativeInfinity(value))
        {
            return "double.NegativeInfinity";
        }

        // Use invariant culture to avoid locale-specific formatting issues
        return value.ToString("G", CultureInfo.InvariantCulture);
    }
}
