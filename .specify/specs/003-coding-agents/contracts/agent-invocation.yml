# Agent Invocation Contract

## Purpose

Defines the expected invocation patterns and response structure for custom GitHub Copilot agents.

## Naming Convention

```yaml
convention:
  agent_files: "indicator-{style}.agent.md (e.g., indicator-series.agent.md)"
  yaml_name: "Simple style name (e.g., name: series, name: buffer, name: streamhub)"
  invocation: "@{yaml_name} (e.g., @series, @buffer, @streamhub)"

note: |
  Agent file names use 'indicator-' prefix to match instruction files.
  YAML name property uses simple names for easy invocation.
  Special case: indicator-stream.agent.md has YAML name 'streamhub' for backward compatibility.
```

## Invocation Pattern

```yaml
pattern: "@{agent-name} {developer-query}"

supported_agents:
  - series    # Series indicator development
  - buffer    # BufferList indicator development
  - streamhub # StreamHub indicator development (plus sub-agents)

examples:
  series:
    - "@series I need to implement a new moving average indicator"
    - "@series How do I validate parameters in a Series indicator?"
    - "@series What test cases are required for Series indicators?"
    - "@series My Series calculations don't match the reference data"

  buffer:
    - "@buffer Which interface should I use for my BufferList indicator?"
    - "@buffer How do I manage buffer state efficiently?"
    - "@buffer What's the correct constructor pattern for BufferList?"
    - "@buffer How do I test BufferList equivalence with Series?"

  streamhub:
    - "@streamhub I need to implement a new streaming indicator"
    - "@streamhub Which provider base class should I use?"
    - "@streamhub Should I use incremental state or full rebuild?"
    - "@streamhub How do I optimize my StreamHub for O(1) updates?"
    - "@streamhub When do I need to override RollbackState?"
```

## Response Structure

```yaml
response:
  components:
    decision_guidance:
      description: "Pattern selection based on query context"
      required: true
      format: "Decision tree section or option selection guidance"
      example: "For your moving average indicator, you should use IIncrementFromChain interface because it chains from IReusable values."

    reference_links:
      description: "Links to instruction file sections for comprehensive details"
      required: true
      format: "Relative markdown links to ../instructions/{file}.instructions.md#{anchor}"
      example: "See [Buffer Management](../instructions/indicator-buffer.instructions.md#buffer-management) for detailed implementation patterns."

    example_code_paths:
      description: "Paths to reference implementations"
      required: true
      format: "Repository-relative paths to canonical examples"
      example: "Reference: `src/s-z/Sma/Sma.BufferList.cs` demonstrates IIncrementFromChain pattern."

    next_steps:
      description: "Actionable developer tasks"
      required: true
      format: "Bulleted list of concrete actions"
      example: |
        Next steps:
        1. Implement IIncrementFromChain interface
        2. Use BufferListUtilities.Update() for buffer management
        3. Inherit from BufferListTestBase in your tests

    related_agents:
      description: "Cross-references to specialized agents when applicable"
      required: false
      format: "Agent invocation syntax with brief context"
      example: "For performance optimization, consult @streamhub-performance."

constraints:
  no_verbatim_duplication:
    description: "Must not copy instruction file content verbatim"
    enforcement: "Manual review during PR"
    rationale: "Agents provide decision guidance; instruction files provide comprehensive details"

  concise:
    description: "Responses should be actionable, not exhaustive"
    target_length: "2-4 paragraphs of guidance plus references"
    rationale: "Developers need quick orientation, not full tutorial"

  references_required:
    description: "Always link to instruction files for details"
    minimum: "1 reference link per response"
    rationale: "Establish instruction files as authoritative source"
```

## Expected Behavior by Query Type

```yaml
query_types:
  implementation_start:
    pattern: "I need to implement..."
    response_includes:
      - File naming guidance
      - Interface/base class selection
      - Reference implementation link
      - Link to code completion checklist
    example_query: "@buffer I need to implement a new momentum BufferList indicator"

  pattern_selection:
    pattern: "Which {pattern/interface/class} should I use?"
    response_includes:
      - Decision tree navigation
      - Selection criteria
      - When-to-use guidance
      - Example indicators using each option
    example_query: "@streamhub Which provider base class should I use?"

  optimization:
    pattern: "How do I optimize/improve..."
    response_includes:
      - Performance anti-patterns to avoid
      - Recommended optimization techniques
      - Reference to performance guidelines
      - Link to specialized agent if applicable
    example_query: "@streamhub My StreamHub is 50x slower than Series. How do I optimize?"

  testing:
    pattern: "How do I test..."
    response_includes:
      - Test base class selection
      - Required test interfaces
      - Test scenario checklist
      - Reference test file link
    example_query: "@series What tests are required for Series indicators?"

  debugging:
    pattern: "My {indicator} {problem}..."
    response_includes:
      - Common causes of the issue
      - Diagnostic steps
      - Reference to relevant patterns
      - Link to constitutional principles if applicable
    example_query: "@buffer My BufferList results don't match Series"

  validation:
    pattern: "How do I validate/handle..."
    response_includes:
      - Validation pattern guidance
      - Exception types to use
      - Edge case handling
      - Link to comprehensive validation section
    example_query: "@series How do I validate parameters?"
```

## Response Quality Criteria

```yaml
quality_gates:
  accuracy:
    - All decision guidance must align with instruction files
    - All reference links must resolve correctly
    - All code examples must exist in repository

  completeness:
    - Address the developer's question directly
    - Provide clear next steps
    - Include at least one instruction file reference
    - Include at least one reference implementation when applicable

  conciseness:
    - Target 150-300 words of guidance
    - Avoid repeating full instruction file content
    - Use bullet points and clear structure

  actionability:
    - Provide concrete actions developer can take immediately
    - Include "what" and "where" (links), not just "how"
    - Prioritize quick wins before complex details
```

## Error Handling

```yaml
edge_cases:
  wrong_agent:
    scenario: "Developer invokes wrong agent for their indicator style"
    response: "Recognize style mismatch, redirect to appropriate agent"
    example: |
      For StreamHub indicators, please consult @streamhub instead.
      Series agents focus on batch processing patterns.

  out_of_scope:
    scenario: "Query outside agent's expertise (e.g., catalog, utilities, non-indicator code)"
    response: "Acknowledge limitation, suggest appropriate resource"
    example: |
      Catalog management is outside indicator implementation scope.
      See `.github/instructions/catalog.instructions.md` for catalog guidelines.

  ambiguous_query:
    scenario: "Query lacks sufficient context to provide specific guidance"
    response: "Ask clarifying questions before providing guidance"
    example: |
      To recommend the best approach, I need to know:
      - Does your indicator require OHLCV data or just values?
      - Does it maintain state between updates?
      - What's the computational complexity?

  conflicting_guidance:
    scenario: "Agent guidance appears to conflict with instruction file"
    response: "Instruction file takes precedence; agent should reference it"
    example: |
      For the authoritative pattern, see [section link].
      If you notice inconsistency, please report it as an issue.
```

## Success Metrics

```yaml
effectiveness_indicators:
  - Developer successfully implements indicator following agent guidance
  - Pull request code review requires minimal corrections to agent-guided code
  - Developer references both agent and instruction file appropriately
  - Developer invokes specialized sub-agents when needed
  - Code completion checklists passed on first attempt

failure_indicators:
  - Developer implements wrong pattern (wrong interface, wrong base class)
  - Developer duplicates instruction file content in code/tests
  - Pull request requires major rework due to missed constitutional principles
  - Developer confused about when to use agent vs instruction file
```

## Integration Points

```yaml
with_instruction_files:
  - Agent provides decision trees → Instruction file provides implementation details
  - Agent links to specific instruction file sections → Developer reads comprehensive guidance
  - Agent suggests reference implementations → Developer studies full code in repository

with_sub_agents:
  - Primary agent (streamhub) → Sub-agents (state, performance, testing, pairs) for deep dives
  - Agent recognizes specialized topics → Redirects to specialized sub-agent
  - Sub-agent provides focused expertise → Links back to primary agent for context

with_constitutional_principles:
  - Agent responses align with constitution (mathematical precision, performance first, etc.)
  - Agent reinforces constitutional requirements in guidance
  - Agent links to constitution when mathematical accuracy or performance issues arise
```
